<!DOCTYPE html>
<html lang="en">
<head>
    <!-- layout logic from Bootstrap -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <!-- Font and traffic monitoring from Google -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Quattrocento+Sans:ital,wght@0,400;0,700;1,400;1,700&family=Quattrocento:wght@400;700&display=swap" rel="stylesheet">


    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Quattrocento+Sans:ital,wght@0,400;0,700;1,400;1,700&family=Quattrocento:wght@400;700&family=Rubik+Mono+One&display=swap" rel="stylesheet">
    <title>FF4 Ultima Plus Fonts</title>
    <style>
.rubik-mono-one-regular {
    font-family: "Rubik Mono One", serif;
    font-weight: 400;
    font-style: normal;
}
.quattrocento-sans-regular {
    font-family: "Quattrocento Sans", serif;
    font-weight: 400;
    font-style: normal;
}
body {
    font-family: "Quattrocento Sans", Arial, sans-serif;
    color: #e4e4e6;
    background: palegoldenrod;
}
h1 {
    font-family: "Rubik Mono One", serif;
}
h2 {
    font-family: "Rubik Mono One", serif;
}
.file-upload {
    margin-bottom: 10px;
    background-color: black;
    color: white;
}
#additional-uploads {
    margin-top: 10px;
}
#manifest {
    white-space: pre-wrap;
    margin-top: 20px;
    margin-left: 20px;
    background-color: antiquewhite;
}
#patch {
    background-color: black;
    color: white;
    font-family: "Rubik Mono One", serif;
}

.core-btn {
  color: gold;
  background-color: #333;
  padding: 6px;
  border-radius: 10px;
}

input::file-selector-button {
  color: gold;
  background-color: #333;
  padding: 6px;
  border-radius: 10px;   
}



#spinner-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  visibility: hidden; /* Hidden on load */
  opacity: 0;
  transition: visibility 0s, opacity 0.3s ease-in-out;
}

.spinner {
  width: 50px;
  height: 50px;
  border: 6px solid #f3f3f3;
  border-top: 6px solid orchid;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

#spinner-overlay.show {
  visibility: visible;
  opacity: 1;
}


/* adapted from https://stackoverflow.com/questions/23441060/how-to-animate-gradients-using-css */
    #gradient
{
    height:100vh;
    width:100vw;
    background: linear-gradient(177deg,maroon, #000, maroon);
    background-size: 200% 200%;

    -webkit-animation: Animation 23s ease infinite;
    -moz-animation: Animation 23s ease infinite;
    animation: Animation 23s ease infinite;
}

@-webkit-keyframes Animation {
    0%{background-position:10% 0%}
    50%{background-position:91% 100%}
    100%{background-position:10% 0%}
}
@-moz-keyframes Animation {
    0%{background-position:10% 0%}
    50%{background-position:91% 100%}
    100%{background-position:10% 0%}
}
@keyframes Animation { 
    0%{background-position:10% 0%}
    50%{background-position:91% 100%}
    100%{background-position:10% 0%}
}
  </style>
  <!-- for unzipping archives -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>


</head>
<body id="gradient" style="font: 1rem 'Quattrocento Sans', sans-serif;">
    <header class="container-fluid">
    <!-- first row, page title -->
    <div class="row justify-content-center">
        <!-- begins single column -->
        <div class="col d-flex justify-content-center">
            <h1 style="font-family: Quattrocento;">
                FF4 Ultima Plus Fonts
            </h1>
        </div>
    </div>
    </header>

<!-- UX element that shows during download then is removed -->
<div id="spinner-overlay" class="spinner-overlay">
    <div class="spinner"></div>
</div>

    <main class="container-fluid">
    <!-- 2nd row, first interaction -->
    <div class="grid gap-0 column-gap-3">
        <!-- begins single column -->
        <div class="col g-col-6">
            <p>Upload your FF4 Ultima Plus ROM and choose a new font.</p>
            <!-- ROM Upload -->
        </div>
        <div class="file-upload col g-col-6">
            <label for="rom">ROM File (.sfc):</label>
            <input type="file" id="rom" accept=".sfc">
        </div>
        <hr/>
    </div>

    <!-- 3rd row, first interaction -->
    <div class="row mx-auto" style="width: 87vw;">
        <!-- begins first column -->
        <div class="col-12 col-sm-6">
        <p>Fonts that are available:</p>
            <ul>
            <li>Chicago6</li>
            <li>Clean Font by xJ4cks</li>
            <li>Monocraft</li>
            <li>mrBrawndo's Ultima IV Font</li>
            <li>Stick Font</li>
            <li>Wide Advance</li>
            </ul>
            <ul>
            <li>Chicago6 (SquishBGone)</li>
            <li>Clean Font by xJ4cks (SquishBGone)</li>
            <li>Monocraft (SquishBGone)</li>
            <li>mrBrawndo's Ultima IV Font (SquishBGone)</li>
            <li>Stick Font (SquishBGone)</li>
            <li>Wide Advance (SquishBGone)</li>
            <li>I-NES (SquishBGone)</li>
            </ul>
        </div>
        <div class="col-12 col-sm-6">
            <img src="./font-previews.gif" 
            alt="previews of the 7 fonts available" 
            style="width: 100%;"/>
        </div>
        <p class="m-3">What are SquishBGone fonts? They rename some things in the game to use as few double letter "squish" tiles as possible. All "SquishBGone" work accomplished by FlamePurge.</p>
    </div>

    <!-- 4th row, second interaction -->
    <div class="grid gap-0 column-gap-0">
        <!-- dropdown of patches -->
        <h2>Choose a Custom Font</h2>
        <select id="patch-dropdown">
            <option value="" disabled selected>Select a patch</option>
        </select>    

        <button id="applyPatch" class="core-btn">Apply Patch</button>
    </div>
    <hr/>
    <!-- 5th row, attribution -->
    <div class="grid gap-0 column-gap-3">
    <h4 style="color:gold;">
        Return to the:
    </h4>
    <!-- black btn styled div -->
    <a href="index.html" style="text-decoration:none;">
        <button class="d-flex justify-content-center align-items-center"
        style="background: black; padding: 1rem; border-radius: 2rem;">
            <h4 style="color:#80a;">
                FF4 Ultima Plus Patcher
            </h4>
        </button>
    </a>

    <!-- 6th row, attribution -->
    <div class="grid gap-0 column-gap-3">
        <h4 style="color:gold;">
            Fonts developed by:
        </h4>
        <p>FlamePurge, mrBrawndo, xJ4cks, Dragonsbrethren, chillyfeez</p>
        <p>FF4 Ultima Plus by <a href="http://ff4ultima.com/">8-bit fan</a> and Team Ultima.</p>
        <p>This webapp coded by <a href="https://jacks.media">xJ4cks</a> & ChatGPT4.</p>
        <p>Final Fantasy IV by Squaresoft, 1991.<br/>Please obey all copyright laws and only use roms<br/>which you own the physical media of.</p>
    </div>


</main>

  <script>
    let romData = null; // Store the uploaded ROM file data
    let zip = null; // Store the loaded ZIP for later access


    // bonus UX, to adjust CSS spinner
    function showSpinner() {
        const spinnerOverlay = document.getElementById('spinner-overlay');
        if (spinnerOverlay) {
            spinnerOverlay.classList.add('show');
        } else {
            console.error('Spinner element not found.');
        }
    }

    function hideSpinner() {
        const spinnerOverlay = document.getElementById('spinner-overlay');
        if (spinnerOverlay) {
            spinnerOverlay.classList.remove('show');
        } else {
            console.error('Spinner element not found.');
        }
    }


    // Handles ROM upload with CRC32 determination
    document.getElementById('rom').addEventListener('change', async (event) => {
        const file = event.target.files[0];
        if (file) {
            const arrayBuffer = await file.arrayBuffer();
            romData = new Uint8Array(arrayBuffer); // Stores ROM data in Uint8Array
            console.log('ROM file uploaded and loaded into memory:', file.name);
            const crc32 = computeCRC32(romData).toString(16).toUpperCase();
            console.log(`ROM CRC32: ${crc32}`);

            // If recommended patch exists, selects in dropdown
            if (romPatchMap[crc32]) {
                const patchDropdown = document.getElementById('patch-dropdown');
                for (let option of patchDropdown.options) {
                    if (option.value === romPatchMap[crc32]) {
                        option.selected = true;
                        console.log(`Auto-selected patch: ${option.value}`);
                        break;
                    }
                }
            }

        }
    });
  
    // Apply IPS Patch Logic
    async function applySelectedPatch() {
    if (!romData) {
        alert('Please upload a ROM file first!');
        return;
    }

    const patchDropdown = document.getElementById('patch-dropdown');
    const selectedPatch = patchDropdown.value;
    if (!selectedPatch) {
        alert('Please select a patch to apply!');
        return;
    }

    try {
        showSpinner(); // Show spinner at the start

        // Fetch the IPS file from the ZIP
        const patchFile = zip.files[selectedPatch];
        if (!patchFile) {
            throw new Error('Patch file not found in ZIP!');
        }

        const patchData = await patchFile.async('uint8array'); // Get patch data as Uint8Array

        // Apply the IPS patch
        const patchedRom = await applyIpsPatch(romData, patchData);
        console.log('Patch applied successfully.');

        // Trigger download of the patched ROM
        downloadPatchedRom(patchedRom, 'patched_rom.sfc');
    } catch (error) {
        console.error('Error applying patch:', error);
        alert(`Error applying patch: ${error.message}`);
    } finally {
        hideSpinner(); // Ensure spinner is hidden in all cases
    }
}


    async function applyIpsPatch(romData, ipsData) {
    const IPS_HEADER = "PATCH";
    const IPS_FOOTER = "EOF";

    let offset = 0;

    // Show spinner at the start
    showSpinner();

    try {
        // Verify header
        const header = new TextDecoder().decode(ipsData.slice(0, 5));
        if (header !== IPS_HEADER) throw new Error("Invalid IPS file: Incorrect header.");
        offset += 5;

        while (offset < ipsData.length) {
            // Check for footer
            if (offset + 3 <= ipsData.length) {
                const footer = new TextDecoder().decode(ipsData.slice(offset, offset + 3));
                if (footer === IPS_FOOTER) {
                    // Valid footer, end processing
                    return romData;
                }
            }

            // Read patch address
            if (offset + 3 > ipsData.length) throw new Error("Invalid IPS file: Unexpected end of data while reading address.");
            const address = (ipsData[offset] << 16) | (ipsData[offset + 1] << 8) | ipsData[offset + 2];
            offset += 3;

            // Read patch size
            if (offset + 2 > ipsData.length) throw new Error("Invalid IPS file: Unexpected end of data while reading size.");
            const size = (ipsData[offset] << 8) | ipsData[offset + 1];
            offset += 2;

            if (size === 0) {
                // RLE (Run Length Encoding)
                if (offset + 3 > ipsData.length) throw new Error("Invalid IPS file: Unexpected end of data in RLE encoding.");
                const rleSize = (ipsData[offset] << 8) | ipsData[offset + 1];
                const value = ipsData[offset + 2];
                offset += 3;

                // Check and expand ROM size if necessary
                const endAddress = address + rleSize;
                if (endAddress > romData.length) {
                    console.warn(`Expanding ROM size to accommodate address: ${endAddress}`);
                    const expandedRom = new Uint8Array(endAddress);
                    expandedRom.set(romData);
                    romData = expandedRom;
                }

                // Apply RLE to ROM data
                for (let i = 0; i < rleSize; i++) {
                    romData[address + i] = value;
                }
            } else {
                // Normal patch
                if (offset + size > ipsData.length) throw new Error("Invalid IPS file: Unexpected end of data in normal patch.");
                const patchData = ipsData.slice(offset, offset + size);
                offset += size;

                // Check and expand ROM size if necessary
                const endAddress = address + size;
                if (endAddress > romData.length) {
                    console.warn(`Expanding ROM size to accommodate address: ${endAddress}`);
                    const expandedRom = new Uint8Array(endAddress);
                    expandedRom.set(romData);
                    romData = expandedRom;
                }

                // Apply patch to ROM data
                for (let i = 0; i < size; i++) {
                    romData[address + i] = patchData[i];
                }
            }
        }

        throw new Error("Invalid IPS file: Missing footer.");
    } finally {
        // Always hides spinner, whether successful or errored out
        hideSpinner();
    }
}



    // Download the patched ROM
    function downloadPatchedRom(data, filename) {
        const blob = new Blob([data], { type: 'application/octet-stream' });
        const url = URL.createObjectURL(blob);
  
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        link.click();
  
        URL.revokeObjectURL(url);
        console.log('Patched ROM downloaded as:', filename);
    }
  
    // Initialize the dropdown with ZIP content
    async function loadLocalZip() {
        const zipFilePath = './fonts.zip'; // Ensure this path is correct
        try {
            const response = await fetch(zipFilePath);
            if (!response.ok) {
                throw new Error(`Failed to fetch ZIP file: ${response.statusText}`);
            }
  
            const zipBlob = await response.blob();
            zip = await JSZip.loadAsync(zipBlob);
  
            console.log('ZIP file loaded successfully:', zip);
  
            // Extract `.ips` files from the `/ff5rc` directory
            const patchFiles = Object.keys(zip.files).filter(relativePath =>
                relativePath.startsWith('') && // Ensure we are within the desired directory
                relativePath.endsWith('.ips') && // Only include `.ips` files
                !zip.files[relativePath].dir // Exclude directories
            );
  
            console.log('Filtered patch files:', patchFiles);
  
            populateDropdown(patchFiles);
        } catch (error) {
            console.error('Error loading or processing ZIP file:', error);
        }
    }
  
    function populateDropdown(patchFiles) {
        const patchDropdown = document.getElementById('patch-dropdown');
        if (!patchDropdown) {
            console.error('Dropdown element not found');
            return;
        }
  
        // Clear existing options
        patchDropdown.innerHTML = '';
  
        // Populate dropdown with the filtered `.ips` files
        patchFiles.forEach(relativePath => {
            const option = document.createElement("option");
            option.value = relativePath; // Set the full path as the value
            option.textContent = relativePath.split('/').pop(); // Show only the file name
            patchDropdown.appendChild(option);
            console.log('Added to dropdown:', relativePath);
        });
  
        console.log('Dropdown options populated:', patchDropdown.options.length);
    }
  
    document.addEventListener('DOMContentLoaded', () => {
        // Load ZIP and populate the dropdown when the page loads
        loadLocalZip();
  
        // Add event listener for the "Apply Patch" button
        document.getElementById('applyPatch').addEventListener('click', applySelectedPatch);
    });


  </script>    


  
</html>
